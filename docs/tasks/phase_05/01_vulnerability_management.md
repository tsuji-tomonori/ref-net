# Task: 脆弱性管理体制の確立

## タスクの目的

依存関係の定期脆弱性スキャン体制を確立し、セキュリティパッチの適時適用プロセスを構築する。

## 前提条件

- Phase 4が完了している
- uvパッケージ管理が稼働中
- CI/CDパイプラインが構築済み
- 00_security_operations.mdが完了している

## 実施内容

### 1. 脆弱性スキャンツールの統合

#### .github/workflows/security-scan.yml (新規作成)

```yaml
name: Security Vulnerability Scan

on:
  schedule:
    # 毎日AM 9:00 (JST) に実行
    - cron: '0 0 * * *'
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  dependency-scan:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.12'

    - name: Install uv
      run: pip install uv

    - name: Install dependencies
      run: |
        cd package/shared && uv sync
        cd ../api && uv sync
        cd ../crawler && uv sync
        cd ../summarizer && uv sync
        cd ../generator && uv sync

    - name: Run Safety scan
      run: |
        for pkg in shared api crawler summarizer generator; do
          echo "Scanning package/$pkg"
          cd package/$pkg
          uv run safety check --json --output ../../reports/safety-$pkg.json || true
          cd ../..
        done
      continue-on-error: true

    - name: Run Bandit scan
      run: |
        for pkg in shared api crawler summarizer generator; do
          echo "Scanning package/$pkg with Bandit"
          cd package/$pkg
          uv run bandit -r src/ -f json -o ../../reports/bandit-$pkg.json || true
          cd ../..
        done
      continue-on-error: true

    - name: Generate vulnerability report
      run: python scripts/generate_vulnerability_report.py

    - name: Upload scan results
      uses: actions/upload-artifact@v4
      with:
        name: security-scan-results
        path: reports/

    - name: Comment PR with results
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          if (fs.existsSync('reports/vulnerability_summary.md')) {
            const summary = fs.readFileSync('reports/vulnerability_summary.md', 'utf8');
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: summary
            });
          }

  docker-scan:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Build Docker images
      run: |
        docker build -t refnet-api package/api/
        docker build -t refnet-shared package/shared/

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: 'refnet-api'
        format: 'json'
        output: 'reports/trivy-api.json'

    - name: Upload Trivy results
      uses: actions/upload-artifact@v4
      with:
        name: docker-scan-results
        path: reports/trivy-*.json
```

### 2. 脆弱性レポート生成スクリプト

#### scripts/generate_vulnerability_report.py (新規作成)

```python
#!/usr/bin/env python3
"""脆弱性スキャン結果レポート生成."""

import json
import os
from datetime import datetime
from pathlib import Path
from typing import Dict, List

import structlog

logger = structlog.get_logger(__name__)


class VulnerabilityReporter:
    """脆弱性レポート生成クラス."""

    def __init__(self):
        """初期化."""
        self.reports_dir = Path("reports")
        self.reports_dir.mkdir(exist_ok=True)

        self.severity_priority = {
            "critical": 4,
            "high": 3,
            "medium": 2,
            "low": 1
        }

    def parse_safety_report(self, filepath: Path) -> Dict:
        """Safetyスキャン結果の解析."""
        if not filepath.exists():
            return {"vulnerabilities": [], "package": filepath.stem.replace("safety-", "")}

        try:
            with open(filepath) as f:
                data = json.load(f)

            vulnerabilities = []
            for vuln in data.get("vulnerabilities", []):
                vulnerabilities.append({
                    "type": "dependency",
                    "package": vuln.get("package"),
                    "version": vuln.get("version"),
                    "severity": vuln.get("severity", "medium").lower(),
                    "description": vuln.get("advisory"),
                    "cve": vuln.get("cve"),
                    "fix_version": vuln.get("fix_versions", [])
                })

            return {
                "vulnerabilities": vulnerabilities,
                "package": filepath.stem.replace("safety-", "")
            }
        except Exception as e:
            logger.error("Failed to parse Safety report", filepath=str(filepath), error=str(e))
            return {"vulnerabilities": [], "package": filepath.stem.replace("safety-", "")}

    def parse_bandit_report(self, filepath: Path) -> Dict:
        """Banditスキャン結果の解析."""
        if not filepath.exists():
            return {"vulnerabilities": [], "package": filepath.stem.replace("bandit-", "")}

        try:
            with open(filepath) as f:
                data = json.load(f)

            vulnerabilities = []
            for result in data.get("results", []):
                vulnerabilities.append({
                    "type": "code",
                    "file": result.get("filename"),
                    "line": result.get("line_number"),
                    "severity": result.get("issue_severity", "medium").lower(),
                    "description": result.get("issue_text"),
                    "test_id": result.get("test_id"),
                    "confidence": result.get("issue_confidence")
                })

            return {
                "vulnerabilities": vulnerabilities,
                "package": filepath.stem.replace("bandit-", "")
            }
        except Exception as e:
            logger.error("Failed to parse Bandit report", filepath=str(filepath), error=str(e))
            return {"vulnerabilities": [], "package": filepath.stem.replace("bandit-", "")}

    def generate_summary_report(self, all_results: List[Dict]) -> str:
        """サマリーレポート生成."""
        total_vulns = sum(len(result["vulnerabilities"]) for result in all_results)

        severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0}

        for result in all_results:
            for vuln in result["vulnerabilities"]:
                severity = vuln.get("severity", "low")
                if severity in severity_counts:
                    severity_counts[severity] += 1

        # 緊急度判定
        urgency = "🟢 LOW"
        if severity_counts["critical"] > 0:
            urgency = "🔴 CRITICAL"
        elif severity_counts["high"] > 0:
            urgency = "🟠 HIGH"
        elif severity_counts["medium"] > 5:
            urgency = "🟡 MEDIUM"

        report = f"""# 脆弱性スキャン結果サマリー

**実行日時**: {datetime.now().isoformat()}
**緊急度**: {urgency}
**総脆弱性数**: {total_vulns}

## 深刻度別集計
- 🔴 Critical: {severity_counts['critical']}
- 🟠 High: {severity_counts['high']}
- 🟡 Medium: {severity_counts['medium']}
- 🟢 Low: {severity_counts['low']}

## パッケージ別詳細
"""

        for result in all_results:
            package = result["package"]
            vulns = result["vulnerabilities"]
            report += f"\n### {package}\n"

            if not vulns:
                report += "✅ 脆弱性は検出されませんでした。\n"
                continue

            # 深刻度順にソート
            vulns_sorted = sorted(vulns,
                                key=lambda x: self.severity_priority.get(x.get("severity", "low"), 0),
                                reverse=True)

            for vuln in vulns_sorted[:5]:  # 上位5件のみ表示
                severity_icon = {"critical": "🔴", "high": "🟠", "medium": "🟡", "low": "🟢"}.get(vuln.get("severity", "low"), "🟢")
                report += f"- {severity_icon} **{vuln.get('package', vuln.get('file', 'Unknown'))}**: {vuln.get('description', 'No description')[:100]}...\n"

            if len(vulns) > 5:
                report += f"- ... その他 {len(vulns) - 5} 件\n"

        report += f"""
## 推奨アクション
"""

        if severity_counts["critical"] > 0:
            report += "⚠️ **即座対応**: Critical脆弱性が検出されています。緊急パッチ適用が必要です。\n"

        if severity_counts["high"] > 0:
            report += "⚠️ **48時間以内**: High脆弱性への対応が必要です。\n"

        if severity_counts["medium"] > 5:
            report += "📋 **1週間以内**: Medium脆弱性が多数検出されています。優先順位を付けて対応してください。\n"

        if total_vulns == 0:
            report += "✅ 脆弱性は検出されませんでした。現在のセキュリティ状態は良好です。\n"

        return report

    def generate_detailed_report(self, all_results: List[Dict]) -> str:
        """詳細レポート生成."""
        report = f"""# 脆弱性詳細レポート
実行日時: {datetime.now().isoformat()}

"""

        for result in all_results:
            package = result["package"]
            vulns = result["vulnerabilities"]

            report += f"## パッケージ: {package}\n\n"

            if not vulns:
                report += "脆弱性は検出されませんでした。\n\n"
                continue

            for i, vuln in enumerate(vulns, 1):
                report += f"### 脆弱性 #{i}\n"
                report += f"- **タイプ**: {vuln.get('type', 'unknown')}\n"
                report += f"- **深刻度**: {vuln.get('severity', 'unknown')}\n"

                if vuln.get("package"):
                    report += f"- **パッケージ**: {vuln['package']} {vuln.get('version', '')}\n"
                if vuln.get("file"):
                    report += f"- **ファイル**: {vuln['file']}:{vuln.get('line', '')}\n"
                if vuln.get("cve"):
                    report += f"- **CVE**: {vuln['cve']}\n"

                report += f"- **説明**: {vuln.get('description', 'No description')}\n"

                if vuln.get("fix_version"):
                    report += f"- **修正バージョン**: {', '.join(vuln['fix_version'])}\n"

                report += "\n"

        return report

    def run(self):
        """レポート生成実行."""
        logger.info("Starting vulnerability report generation")

        packages = ["shared", "api", "crawler", "summarizer", "generator"]
        all_results = []

        # Safetyレポート解析
        for package in packages:
            safety_file = self.reports_dir / f"safety-{package}.json"
            result = self.parse_safety_report(safety_file)
            if result["vulnerabilities"]:
                all_results.append(result)

        # Banditレポート解析
        for package in packages:
            bandit_file = self.reports_dir / f"bandit-{package}.json"
            result = self.parse_bandit_report(bandit_file)
            if result["vulnerabilities"]:
                all_results.append(result)

        # レポート生成
        summary = self.generate_summary_report(all_results)
        detailed = self.generate_detailed_report(all_results)

        # ファイル出力
        with open(self.reports_dir / "vulnerability_summary.md", "w") as f:
            f.write(summary)

        with open(self.reports_dir / "vulnerability_detailed.md", "w") as f:
            f.write(detailed)

        # JSON出力
        json_report = {
            "timestamp": datetime.now().isoformat(),
            "total_vulnerabilities": sum(len(result["vulnerabilities"]) for result in all_results),
            "results": all_results
        }

        with open(self.reports_dir / "vulnerability_report.json", "w") as f:
            json.dump(json_report, f, indent=2)

        logger.info("Vulnerability report generation completed")
        print(summary)


def main():
    """メイン処理."""
    reporter = VulnerabilityReporter()
    reporter.run()


if __name__ == "__main__":
    main()
```

### 3. パッチ適用手順の策定

#### docs/security/patch_management.md (新規作成)

```markdown
# セキュリティパッチ管理手順

## パッチ適用優先度

### Critical（即座対応）
- CVEスコア 9.0 以上
- 認証バイパス脆弱性
- リモートコード実行脆弱性
- データ漏洩に直結する脆弱性

**対応期限**: 24時間以内

### High（緊急対応）
- CVEスコア 7.0-8.9
- 権限昇格脆弱性
- サービス停止につながる脆弱性

**対応期限**: 48時間以内

### Medium（計画的対応）
- CVEスコア 4.0-6.9
- 情報漏洩脆弱性
- DoS攻撃脆弱性

**対応期限**: 1週間以内

### Low（定期対応）
- CVEスコア 3.9 以下
- 軽微な情報漏洩
- 設定上の問題

**対応期限**: 1ヶ月以内

## パッチ適用手順

### 1. 脆弱性評価
1. 脆弱性スキャン結果の確認
2. CVEデータベースでの詳細確認
3. 自システムへの影響度評価
4. 優先度決定

### 2. パッチ計画
1. 修正方法の調査（バージョンアップ、設定変更等）
2. テスト計画の策定
3. ダウンタイム計画
4. ロールバック計画

### 3. テスト環境での検証
1. パッチ適用
2. 機能テストの実行
3. パフォーマンステスト
4. セキュリティテスト

### 4. 本番適用
1. 事前バックアップ
2. パッチ適用
3. 動作確認
4. 監視強化

### 5. 事後確認
1. 脆弱性修正の確認
2. システム安定性の確認
3. パッチ適用記録の更新
4. 次回定期スキャンでの確認

## 緊急パッチ適用手順

### Critical脆弱性の場合
1. **即座通知**: セキュリティチーム・管理職へ緊急連絡
2. **影響評価**: 最大30分で影響範囲を特定
3. **緊急対応**: 必要に応じてサービス停止
4. **パッチ適用**: テスト簡素化して即座適用
5. **事後検証**: 24時間以内に詳細検証

### High脆弱性の場合
1. **通知**: セキュリティチーム・開発チームへ連絡
2. **計画策定**: 24時間以内にパッチ計画策定
3. **テスト実行**: 基本テストのみ実行
4. **適用実行**: 48時間以内に本番適用
5. **監視強化**: 適用後72時間の監視強化

## 依存関係更新コマンド

### 個別パッケージ更新
```bash
# 特定パッケージの更新
cd package/[target_package]
uv add [package_name]@[version]

# セキュリティのみ更新
uv sync --upgrade-package [package_name]
```

### 全パッケージ更新
```bash
# 全体の依存関係更新
./scripts/update_dependencies.sh

# テスト実行
moon :check
```

### Docker イメージ更新
```bash
# ベースイメージ更新
docker build --no-cache -t refnet-api package/api/
docker build --no-cache -t refnet-shared package/shared/

# 脆弱性スキャン
docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
  aquasec/trivy image refnet-api
```

## 記録・レポート

### パッチ適用記録
- 適用日時
- 対象脆弱性（CVE番号）
- 適用方法
- ダウンタイム
- 問題・対応

### 月次レポート
- 適用済みパッチ一覧
- 未適用脆弱性一覧
- セキュリティ指標の推移
- 改善提案
```

### 4. 依存関係更新スクリプト

#### scripts/update_dependencies.sh (新規作成)

```bash
#!/bin/bash

# 依存関係の安全な更新スクリプト

set -e

BACKUP_DIR="/tmp/uv_backup_$(date +%Y%m%d_%H%M%S)"
LOG_FILE="/tmp/dependency_update.log"

echo "依存関係更新を開始します..." | tee "$LOG_FILE"

# バックアップ作成
echo "現在のuv.lockファイルをバックアップ中..." | tee -a "$LOG_FILE"
mkdir -p "$BACKUP_DIR"
find . -name "uv.lock" -exec cp {} "$BACKUP_DIR/" \;

# 各パッケージの更新
PACKAGES=("shared" "api" "crawler" "summarizer" "generator")

for package in "${PACKAGES[@]}"; do
    echo "パッケージ $package を更新中..." | tee -a "$LOG_FILE"

    cd "package/$package"

    # 現在のバージョン記録
    uv export --format=requirements-txt > "$BACKUP_DIR/${package}_before.txt"

    # 依存関係更新
    if uv sync --upgrade; then
        echo "✅ $package の依存関係更新完了" | tee -a "$LOG_FILE"

        # 更新後のバージョン記録
        uv export --format=requirements-txt > "$BACKUP_DIR/${package}_after.txt"
    else
        echo "❌ $package の依存関係更新失敗" | tee -a "$LOG_FILE"
        # 失敗時はロールバック
        cp "$BACKUP_DIR/uv.lock" .
    fi

    cd ../..
done

# テスト実行
echo "更新後のテスト実行中..." | tee -a "$LOG_FILE"
if moon :check; then
    echo "✅ 全テストが成功しました" | tee -a "$LOG_FILE"

    # 脆弱性スキャン実行
    echo "脆弱性スキャン実行中..." | tee -a "$LOG_FILE"
    python scripts/generate_vulnerability_report.py

    echo "依存関係更新が完了しました。バックアップ: $BACKUP_DIR" | tee -a "$LOG_FILE"
else
    echo "❌ テストが失敗しました。ロールバックを実行します..." | tee -a "$LOG_FILE"

    # ロールバック
    for package in "${PACKAGES[@]}"; do
        cp "$BACKUP_DIR/uv.lock" "package/$package/"
    done

    echo "ロールバック完了。詳細は $LOG_FILE を確認してください。" | tee -a "$LOG_FILE"
    exit 1
fi
```

## 完了条件

### 必須条件
- [ ] GitHub Actionsによる脆弱性スキャンが稼働している
- [ ] 脆弱性レポート生成スクリプトが動作する
- [ ] パッチ管理手順が文書化されている
- [ ] 依存関係更新スクリプトが動作する
- [ ] 初回スキャン結果の確認・対応が完了している

### 自動化確認
- [ ] 日次での自動スキャンが実行される
- [ ] PRでの脆弱性チェックが動作する
- [ ] スキャン結果がSlackやメールで通知される
- [ ] Critical/High脆弱性の自動アラートが動作する

### プロセス確認
- [ ] パッチ適用優先度が明確に定義されている
- [ ] 緊急時対応手順がテスト済み
- [ ] 依存関係更新が安全に実行できる
- [ ] 月次の脆弱性レポートが生成される

## 推定作業時間

**10-15時間**
- GitHub Actions設定：2-3時間
- 脆弱性レポート実装：4-5時間
- パッチ管理手順策定：2-3時間
- 更新スクリプト実装：2-3時間
- テスト・検証：2-3時間

## 優先度

**📋 中優先度** - Phase 4完了後の運用フェーズで対応

## 依存関係

- 00_security_operations.md（監査体制）
- CI/CDパイプライン
- Slack/メール通知システム（推奨）
